# 이슈 작성 가이드

## 📋 이슈 종류 설명

### 1. Epic (대분류)

**언제 사용?** 큰 기능을 만들 때 (예: "게시판 기능 전체")

- 여러 개의 작은 작업(Story)으로 쪼갤 수 있는 큰 기능
- 보통 1~2주 이상 걸리는 작업

**작성 항목:**

- **목표**: 왜 이걸 만드는지, 완성되면 어떤 결과가 나오는지
- **범위**: 어디까지 만들 건지 / 무엇은 제외할 건지
- **디자인/문서 링크**: 피그마, 기획서 등의 링크
- **하위 스토리**: 이 Epic을 완성하기 위한 작은 Story들
- **마일스톤**: 언제까지 완성할 건지

---

### 2. Story (중분류)

**언제 사용?** 사용자 관점에서 하나의 완결된 기능 (예: "게시글 작성하기")

- 사용자가 직접 사용하는 기능 하나
- 보통 2~5일 정도 걸리는 작업

**작성 항목:**

- **배경**: 왜 이 기능이 필요한지
- **수용 기준(AC)**: 이 기능이 완성됐다고 할 수 있는 조건들 (체크리스트)
- **디자인/계약 링크**: 화면 디자인, API 명세서 등
- **구현 메모/리스크**: 주의할 점이나 예상되는 문제
- **연결된 Epic**: 이 Story가 속한 Epic 번호

---

### 3. Task (소분류)

**언제 사용?** 개발자가 실제로 코딩하는 단위 작업 (예: "게시글 저장 API 개발")

- 실제로 코드를 작성하는 작은 작업
- 보통 반나절~1일 정도 걸리는 작업

**작성 항목:**

- **연결된 Story/Epic**: 어떤 Story의 일부인지
- **작업 범위**: 정확히 무엇을 만들 건지
- **Done 기준**: 완료 조건 (테스트, 문서, 코드리뷰 등)

---

### 4. Spike (조사)

**언제 사용?** 어떻게 만들지 모르겠어서 조사가 필요할 때

- 새로운 기술을 써야 하는데 잘 모를 때
- 여러 방법 중 어떤 게 좋은지 비교해야 할 때

**작성 항목:**

- **타임박스**: 조사에 쓸 시간 제한 (예: 1일, 4시간)
- **핵심 질문**: 무엇을 알아내고 싶은지
- **접근 방법**: 어떻게 조사할 건지
- **산출물**: 조사 결과를 어디에 정리할 건지

---

### 5. Change Request (변경 요청)

**언제 사용?** 이미 계획된 내용을 바꿔야 할 때

- 디자인이 바뀌었을 때
- 기획이 수정됐을 때
- 더 좋은 방법을 발견했을 때

**작성 항목:**

- **영향받는 Epic/Story/Task**: 어떤 이슈들이 영향을 받는지
- **제안 변경 사항**: 무엇을 어떻게 바꿀 건지
- **영향도**: 백엔드/프론트엔드/DB 등 어디에 영향이 있는지
- **결정/대안/근거**: 왜 이렇게 바꾸는 게 좋은지

---

## 🎯 실전 예시: OAuth 소셜 로그인 기능 구현

### 예시 시나리오

프론트엔드에서 소셜 로그인 UI를 완성했고, 이제 백엔드 인증 서버 개발을 시작하려고 합니다.

---

### 1단계: Epic 생성

```
제목: [EPIC] OAuth 소셜 로그인 기능 구현

목표:
사용자가 Google, Kakao, Naver 계정으로 간편하게 로그인할 수 있는
OAuth 인증 시스템을 구축하여 사용자 접근성을 개선한다.
성공 지표: 소셜 로그인 성공률 95% 이상, 평균 로그인 시간 3초 이내

범위 / Not-in-scope:
포함: Google/Kakao/Naver OAuth 연동, JWT 토큰 발급, 리프레시 토큰
제외: 이메일/비밀번호 로그인 (이미 구현됨), 2FA 인증 (다음 버전)

디자인/문서 링크:
https://www.figma.com/design/소셜로그인디자인

하위 스토리:
- [ ] #101 Google OAuth 연동
- [ ] #102 Kakao OAuth 연동
- [ ] #103 Naver OAuth 연동
- [ ] #104 JWT 토큰 발급 및 검증

마일스톤:
2025-11-30
```

---

### 2단계: Story 생성 (Epic의 하위 작업)

```
제목: [STORY] Google OAuth 연동

배경:
많은 사용자가 Google 계정을 보유하고 있어, Google 로그인을
제공하면 회원가입/로그인 과정이 간소화되어 사용자 경험이 개선된다.

수용 기준(AC):
- [ ] Google OAuth 2.0 인증 플로우가 정상 작동한다
- [ ] 인증 코드로 액세스 토큰을 받아올 수 있다
- [ ] Google에서 사용자 정보(이메일, 이름, 프로필 이미지)를 가져온다
- [ ] 신규 사용자는 자동으로 회원가입 처리된다
- [ ] 기존 사용자는 로그인 처리되고 JWT 토큰이 발급된다
- [ ] 인증 실패 시 적절한 에러 메시지가 반환된다

디자인/계약 링크:
- API 명세: docs/api/oauth-api.md
- Google OAuth 문서: https://developers.google.com/identity/protocols/oauth2

구현 메모/리스크:
- Google OAuth Client ID/Secret은 환경변수로 관리
- 리다이렉트 URI는 프론트엔드와 협의 필요
- Rate Limiting 적용하여 무차별 로그인 시도 방지

연결된 Epic:
#100
```

---

### 3단계: Task 생성 (Story를 실제 작업으로 쪼개기)

#### Task 1: Google OAuth 인증 엔드포인트 개발

```
제목: [TASK] Google OAuth 인증 API 개발

연결된 Story/Epic:
#101

작업 범위:
- POST /api/auth/oauth/google 엔드포인트 생성
- 요청: { code: string, redirectUri: string }
- Google OAuth API를 통해 액세스 토큰 획득
- 사용자 정보 조회 (email, name, profile_image)
- 신규 사용자 자동 회원가입 처리
- JWT Access/Refresh 토큰 발급
- 응답: { accessToken, refreshToken, user: {...} }

Done 기준:
- [x] 테스트 작성 (단위 테스트, 통합 테스트)
- [x] 문서/스키마 업데이트 (API 명세서)
- [x] 린트/빌드/CI 통과
- [ ] PR 리뷰/머지
```

#### Task 2: OAuth 사용자 정보 저장 로직

```
제목: [TASK] OAuth 사용자 엔티티 및 Repository 구현

연결된 Story/Epic:
#101

작업 범위:
- Auth 엔티티에 provider(GOOGLE/KAKAO/NAVER) 필드 추가
- provider + provider_user_id로 중복 체크
- ConsentService와 연동하여 기본 동의 항목 처리
- History에 로그인 이력 저장

Done 기준:
- [x] 테스트 작성 (Repository 테스트)
- [x] 문서/스키마 업데이트
- [ ] 린트/빌드/CI 통과
- [ ] PR 리뷰/머지
```

---

### 4단계: Spike 생성 (조사가 필요한 경우)

```
제목: [SPIKE] JWT 토큰 저장소 선정 (Redis vs In-Memory)

타임박스:
1일 (8시간)

핵심 질문:
- Refresh Token을 어디에 저장해야 하는가?
- Redis vs In-Memory Cache 중 어떤 것이 적합한가?
- 토큰 만료 관리는 어떻게 할 것인가?

접근 방법:
1. Redis와 In-Memory Cache의 장단점 비교
2. 간단한 POC 코드로 성능 테스트
3. 서버 재시작 시 토큰 유지 여부 확인
4. 동시 접속자 수에 따른 메모리 사용량 측정
5. 팀원들과 논의

산출물:
- docs/adr/0001-token-storage-selection.md (결정 사항 문서)
- GitHub에 POC 브랜치 커밋 (성능 테스트 결과 포함)
```

---

### 5단계: Change Request 생성 (변경이 필요한 경우)

**상황:** 개발 중에 보안 검토 결과 토큰 만료 정책 변경이 필요함

```
제목: [CR] JWT 토큰 만료 시간 정책 변경

영향받는 Epic/Story/Task:
#100, #101, #104

제안 변경 사항:
보안 강화를 위해 JWT Access Token 만료 시간 변경
- 기존: Access Token 24시간, Refresh Token 30일
- 변경: Access Token 30분, Refresh Token 7일
- Token Refresh API 추가 필요

영향도:
- 백엔드: TokenUtil 만료 시간 설정 변경, Refresh API 추가
- 프론트엔드: 30분마다 자동 토큰 갱신 로직 추가
- DB: refresh_tokens 테이블 TTL 설정 변경

결정/대안/근거:
보안 감사 결과 24시간은 너무 길다는 피드백을 받음.
업계 표준(15분~1시간)을 고려하여 30분으로 설정.
구현 난이도는 중간(2일), 보안 개선 효과가 크므로 변경하기로 결정.
대안1: 15분 → 사용자 경험 저하 우려로 거부
대안2: 유지 → 보안 리스크가 크므로 거부
```

---

## 🔄 작업 흐름 요약

```
Epic 생성 (큰 기능)
  ↓
Story 생성 (사용자 기능)
  ↓
Task 생성 (실제 개발 작업)
  ↓
개발 진행
  ↓
필요시 Spike (조사) 또는 Change Request (변경)
```

---

## 💡 팁

1. **Epic은 크게, Task는 작게**
	- Epic: 1~2주 이상
	- Story: 2~5일
	- Task: 반나절~1일

2. **연결은 필수**
	- Task는 반드시 Story나 Epic과 연결
	- 고아 이슈를 만들지 마세요

3. **체크리스트 활용**
	- Story의 AC(수용 기준)은 체크리스트로
	- Task의 Done 기준도 체크리스트로
	- 완료 조건이 명확해집니다

4. **링크는 구체적으로**
	- "피그마 참고"보다는 정확한 URL
	- 나중에 찾기 쉽습니다

5. **변경은 CR로**
	- 기존 이슈를 함부로 수정하지 말고
	- Change Request로 변경 이력을 남기세요
