# docker-compose.yml — Auth Server 프로덕션 배포
#
# 네트워크 구성:
#   - auth-network: 내부 전용 (DB, Redis, MaxScale)
#   - infra-network: 공용 (Kafka) - 외부에서 생성 필요
#
# 사용법:
#   docker network create infra-network  # 최초 1회
#   docker-compose up -d

services:
  # ═══════════════════════════════════════════════════════════════
  # LOAD BALANCER (Nginx)
  # ═══════════════════════════════════════════════════════════════
  nginx:
    image: nginx:alpine
    container_name: nginx-auth
    ports:
      - "9010:80"
    volumes:
      - ./nginx/conf/default.conf:/etc/nginx/conf.d/default.conf:ro
      - ./nginx/logs:/var/log/nginx
    depends_on:
      - auth-server-1
    networks:
      - auth-network
    restart: unless-stopped
    logging:
      driver: "json-file"
      options:
        max-size: "50m"
        max-file: "3"

  # ═══════════════════════════════════════════════════════════════
  # APPLICATION SERVERS
  # ═══════════════════════════════════════════════════════════════
  auth-server-1:
    image: ddingsh9/auth-server:latest
    container_name: auth-server-1
    env_file:
      - .env.prod
    environment:
      # Spring Profile & Application Name
      SPRING_PROFILES_ACTIVE: prod
      SPRING_APPLICATION_NAME: auth-service
      # MaxScale 연결 (내부 네트워크)
      SPRING_DATASOURCE_URL: jdbc:mariadb://maxscale:4006/${DATABASE_NAME}
      SPRING_DATASOURCE_USERNAME: ${DATABASE_USER_NAME}
      SPRING_DATASOURCE_PASSWORD: ${DATABASE_PASSWORD}
      # Kafka 연결 (공용 네트워크)
      SPRING_KAFKA_BOOTSTRAP_SERVERS: ${KAFKA_URL1},${KAFKA_URL2},${KAFKA_URL3}
      # Redis 연결 (내부 네트워크)
      SPRING_DATA_REDIS_HOST: redis
      SPRING_DATA_REDIS_PORT: 6379
      # JWT 설정 (Spring @Value 속성 경로에 맞춰 변환)
      SECURITY_JWT_SECRET: ${JWT_SECRET}
      SECURITY_JWT_ACCESS_TOKEN_EXPIRE_TIME: ${JWT_ACCESS_TOKEN_EXPIRE_TIME}
      SECURITY_JWT_REFRESH_TOKEN_EXPIRE_TIME: ${JWT_REFRESH_TOKEN_EXPIRE_TIME}
      # AES 암호화 키
      SECURITY_AES_ENCRYPTION_KEY: ${AES_ENCRYPTION_KEY}
      # Distributed Tracing (Zipkin)
      ZIPKIN_ENDPOINT: http://zipkin:9411/api/v2/spans
      TRACING_SAMPLING_PROBABILITY: 0.1
    networks:
      - auth-network    # 내부: DB, Redis, MaxScale
      - infra-network   # 공용: Kafka
    depends_on:
      maxscale:
        condition: service_healthy
      redis:
        condition: service_healthy
    restart: unless-stopped
    healthcheck:
      test: [ "CMD", "curl", "-f", "http://localhost:8080/health" ]
      interval: 15s
      timeout: 5s
      retries: 3
      start_period: 30s
    logging:
      driver: "json-file"
      options:
        max-size: "50m"
        max-file: "3"

  # 추가 인스턴스 (필요 시 주석 해제)
  # auth-server-2:
  #   image: ddingsh9/auth-server:latest
  #   container_name: auth-server-2
  #   env_file:
  #     - .env.prod
  #   environment:
  #     SPRING_PROFILES_ACTIVE: prod
  #     SPRING_DATASOURCE_URL: jdbc:mariadb://maxscale:4006/${DATABASE_NAME}
  #     SPRING_DATASOURCE_USERNAME: ${DATABASE_USER_NAME}
  #     SPRING_DATASOURCE_PASSWORD: ${DATABASE_PASSWORD}
  #     SPRING_KAFKA_BOOTSTRAP_SERVERS: ${KAFKA_URL1},${KAFKA_URL2},${KAFKA_URL3}
  #     SPRING_DATA_REDIS_HOST: redis
  #     SPRING_DATA_REDIS_PORT: 6379
  #     SECURITY_JWT_SECRET: ${JWT_SECRET}
  #     SECURITY_JWT_ACCESS_TOKEN_EXPIRE_TIME: ${JWT_ACCESS_TOKEN_EXPIRE_TIME}
  #     SECURITY_JWT_REFRESH_TOKEN_EXPIRE_TIME: ${JWT_REFRESH_TOKEN_EXPIRE_TIME}
  #     SECURITY_AES_ENCRYPTION_KEY: ${AES_ENCRYPTION_KEY}
  #   networks:
  #     - auth-network
  #     - infra-network
  #   depends_on:
  #     maxscale:
  #       condition: service_healthy
  #     redis:
  #       condition: service_healthy
  #   restart: unless-stopped
  #   healthcheck:
  #     test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
  #     interval: 15s
  #     timeout: 5s
  #     retries: 3
  #   logging:
  #     driver: "json-file"
  #     options:
  #       max-size: "50m"
  #       max-file: "3"

  # ═══════════════════════════════════════════════════════════════
  # DATABASE LAYER (Master/Slave + MaxScale) - 내부 네트워크만
  # ═══════════════════════════════════════════════════════════════
  mariadb-master:
    image: mariadb:11.4
    container_name: mariadb-master
    environment:
      MARIADB_ROOT_PASSWORD: ${DB_ROOT_PASSWORD}
      MARIADB_DATABASE: ${DATABASE_NAME}
      MARIADB_USER: ${DATABASE_USER_NAME}
      MARIADB_PASSWORD: ${DATABASE_PASSWORD}
    volumes:
      - ./docker/master/conf.d:/etc/mysql/conf.d:ro
      - ./docker/master/init:/docker-entrypoint-initdb.d:ro
      - mariadb-master-data:/var/lib/mysql
    command:
      - --server-id=1
      - --log-bin=mysql-bin
      - --binlog-format=ROW
      - --gtid_strict_mode=ON
      - --log-slave-updates=ON
    networks:
      - auth-network   # 내부 네트워크만
    restart: unless-stopped
    healthcheck:
      test: [ "CMD", "healthcheck.sh", "--connect", "--innodb_initialized" ]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s
    logging:
      driver: "json-file"
      options:
        max-size: "50m"
        max-file: "3"

  mariadb-slave:
    image: mariadb:11.4
    container_name: mariadb-slave
    environment:
      MARIADB_ROOT_PASSWORD: ${DB_ROOT_PASSWORD}
      MARIADB_DATABASE: ${DATABASE_NAME}
      MARIADB_USER: ${DATABASE_USER_NAME}
      MARIADB_PASSWORD: ${DATABASE_PASSWORD}
    volumes:
      - ./docker/slave/conf.d:/etc/mysql/conf.d:ro
      - ./docker/slave/init:/docker-entrypoint-initdb.d:ro
      - mariadb-slave-data:/var/lib/mysql
    command:
      - --server-id=2
      - --log-bin=mysql-bin
      - --binlog-format=ROW
      - --gtid_strict_mode=ON
      - --log-slave-updates=ON
      - --read-only=ON
    depends_on:
      mariadb-master:
        condition: service_healthy
    networks:
      - auth-network   # 내부 네트워크만
    restart: unless-stopped
    healthcheck:
      test: [ "CMD", "healthcheck.sh", "--connect", "--innodb_initialized" ]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s
    logging:
      driver: "json-file"
      options:
        max-size: "50m"
        max-file: "3"

  maxscale:
    image: mariadb/maxscale:latest
    container_name: maxscale
    volumes:
      - ./docker/maxscale/maxscale.cnf:/etc/maxscale.cnf:ro
    depends_on:
      mariadb-master:
        condition: service_healthy
      mariadb-slave:
        condition: service_healthy
    networks:
      - auth-network   # 내부 네트워크만
    restart: unless-stopped
    healthcheck:
      test: [ "CMD", "maxctrl", "list", "servers" ]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 20s
    logging:
      driver: "json-file"
      options:
        max-size: "50m"
        max-file: "3"

  # ═══════════════════════════════════════════════════════════════
  # REDIS - 내부 네트워크만
  # ═══════════════════════════════════════════════════════════════
  redis:
    image: redis:7-alpine
    container_name: redis-auth
    command: redis-server --appendonly yes --maxmemory 256mb --maxmemory-policy allkeys-lru
    volumes:
      - redis-data:/data
    networks:
      - auth-network   # 내부 네트워크만
    restart: unless-stopped
    healthcheck:
      test: [ "CMD", "redis-cli", "ping" ]
      interval: 10s
      timeout: 5s
      retries: 5
    logging:
      driver: "json-file"
      options:
        max-size: "50m"
        max-file: "3"

  # ═══════════════════════════════════════════════════════════════
  # ZIPKIN (Distributed Tracing)
  # ═══════════════════════════════════════════════════════════════
  zipkin:
    image: openzipkin/zipkin
    container_name: zipkin
    ports:
      - "9411:9411"
    environment:
      - STORAGE_TYPE=mem  # 프로덕션에서는 Elasticsearch 연동 권장
    networks:
      - auth-network
    restart: unless-stopped
    healthcheck:
      test: [ "CMD-SHELL", "wget -q --spider http://localhost:9411/health || exit 1" ]
      interval: 10s
      timeout: 5s
      retries: 5
    logging:
      driver: "json-file"
      options:
        max-size: "50m"
        max-file: "3"

  # ═══════════════════════════════════════════════════════════════
  # LOG CLEANER
  # ═══════════════════════════════════════════════════════════════
  log-cleaner:
    image: alpine:3.19
    container_name: log-cleaner
    volumes:
      - ./nginx/logs:/host/nginx/logs
    command: >
      sh -c "while true; do
        find /host/nginx/logs -type f -name '*.log' -mtime +7 -delete || true;
        sleep 3600;
      done"
    restart: unless-stopped

# ═══════════════════════════════════════════════════════════════
# NETWORKS
# ═══════════════════════════════════════════════════════════════
networks:
  # 내부 네트워크: DB, Redis, MaxScale (외부 접근 불가)
  auth-network:
    driver: bridge
    name: auth-network
    internal: false  # Nginx가 외부 트래픽 수신 필요

  # 공용 네트워크: Kafka (다른 MSA 서비스와 공유)
  infra-network:
    external: true
    name: infra-network

# ═══════════════════════════════════════════════════════════════
# VOLUMES
# ═══════════════════════════════════════════════════════════════
volumes:
  mariadb-master-data:
    name: auth-mariadb-master-data
  mariadb-slave-data:
    name: auth-mariadb-slave-data
  redis-data:
    name: auth-redis-data
